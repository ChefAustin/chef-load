#!/bin/bash
#
# This file is meant to have all the helper methods that
# Go components will use like the config_mgmt/ingest/etc

# Run Unit tests
document "go_component_unit" <<DOC
  Runs unit testing for the specified component

  Example: Run the unit tests for the config-mgmt-service
  ----------------------------------------------------
  $ go_component_unit config-mgmt-service
DOC
function go_component_unit() {
  setup_go_workspace
  echo "running " $1
  pushd $scaffolding_go_pkg_path >/dev/null;
    local GO_PACKAGES=$(go list ./components/$1/... | grep -v integration);
  popd >/dev/null
  go_test $GO_PACKAGES
}

complete -F _component_auto_compelete go_component_unit

# TODO: (@afiune) Document the use of go_test and maybe put in ci-studio-common
function go_test() {
  # Need to set the 'pkg_name' back to a2 because when building
  # a component the 'pkg_name' changes to the component name
  pkg_name=a2
  setup_go_workspace
  install_if_missing core/go go;
  install_if_missing core/git git;

  [[ $RUN_GO_DEP == true ]] && dep_ensure;

  pushd $scaffolding_go_pkg_path >/dev/null;
    echo "=> Executing Go test";
    # The default behavior is to run the package at the root of the
    # repository which is just as if we run: 'go test -cover -v'
    go test "$@" -cover -v
    local EXIT_CODE=$?;
  popd >/dev/null;
  return $EXIT_CODE;
}

document "go_build_pkg" <<DOC
  Build one or more go packages within the a2 codebase

  Examples:

      go_build_pkg components/automate-deployment/cmd/automate-ctl
      go_build_pkg components/automate-deployment/pkg/server
DOC
function go_build_pkg() {
  if [[ "$1" == "" ]]; then
      echo "Missing package path; try 'describe ${FUNCNAME[0]}'"
      return 1
  fi

  setup_go_workspace
  [[ ! -d /src/bin ]] && mkdir /src/bin

  local pkg_path="github.com/chef/a2/$1"

  pushd /src/bin >/dev/null
    echo "=> go build $pkg_path"
    go build -i "$pkg_path"
    # Save the exit code to return it latter
    # this will make the function to exit with
    # a non-zero code and don't procees from there
    EXIT_CODE=$?
  popd >/dev/null
  return $EXIT_CODE
}

document "go_build_component" <<DOC
  A wrapper around the go_build to build a specific component.
DOC
function go_build_component() {
  [[ "$1" == "" ]] && echo "Missing component name argument; try 'describe ${FUNCNAME[0]}'" && return 1;
  verify_component $1 || return $?
  local component=$1

  # Need to set the 'pkg_name' back to a2 because when building
  # a component the 'pkg_name' changes to the component name
  pkg_name=a2

  # Create bin folder if missing
  [[ ! -d /src/bin ]] && mkdir /src/bin

  # Verify if the provided component is compliance,
  # if it is, use their special method to build their binary
  if [[ "$component" == "compliance-service" ]]; then
    go_build_compliance_service
  else
    go_build "components/${component}/cmd/*/*.go" /src/bin/${component}
  fi
}
# Adding auto tab complete
complete -F _component_auto_compelete go_build_component

document "reload_component_binary" <<DOC
  Reloads the $pkg_name binary from the '/src' directory. (Build a binary with 'go_build')

  This helper will force load a binary located at '/src/$pkg_name' into your already installed
  habitat package. If no package have been installed, it will try to install one.
DOC
function reload_component_binary() {
  [ "x$1" == "x" ] && echo "Missing component name argument; try 'describe ${FUNCNAME[0]}'" && return 1
  verify_component $1 || return $?
  local component=$1

  component_path=$(hab pkg path $HAB_ORIGIN/$component 2> /dev/null)
  if [[ $? -ne 0 ]]; then
    component_path=$(hab pkg path chef/$component 2> /dev/null)
    if [[ $? -ne 0 ]]; then
      echo "Could not find $component deployed under either your origin ($HAB_ORIGIN) or chef origin."
      echo "Deploy A2 and try again."
      return 1
    fi
  fi

  [ ! -f /src/bin/${component} ] && go_build_component $component

  # TODO: (@afiune) This is a bit too extreme but what we are trying to avoid is to
  # be polling to the depot for newer packages, since we disable that functionality
  # we have to force load the binary like this. Maybe I'll revisit this latter.
  echo "=> Reloading $component binary"
  # we need to unlink the old one so that the new one my be updated and then relinked
  unlink ${component_path}/bin/${component}
  kill_running_service $component
  cp /src/bin/${component} ${component_path}/bin/${component}
  if [[ $? != 0 ]]; then
    echo -e "=> There was a problem trying to reload the $component binary."
    echo -e "   Run 'go_build_component $component' and try again."
    echo -e "   Or run 'go_update_component $component' to build and reload the binary."
    return 1
  fi

  return 0
}

# Adding auto tab complete
complete -F _component_auto_compelete reload_component_binary

document "go_update_component" <<DOC
  Go update will generate a new binary (go_build) and force load it (reload_binary).

  To just build the Go binary without running the dependency solver:
  => GO_FAST=true go_update_component [COMPONENT_NAME]
DOC
function go_update_component() {
  [ "x$1" == "x" ] && echo "Missing component name argument; try 'describe ${FUNCNAME[0]}'" && return 1
  verify_component $1 || return $?
  local component=$1

  hab pkg path $HAB_ORIGIN/$component 2>/dev/null 1>&2 || hab pkg path chef/$component 2>/dev/null 1>&2
  if [ $? -eq 0 ] ; then
    go_build_component $component
    reload_component_binary $component
  else
    echo "You must first deploy A2."
  fi
}
# Adding auto tab complete
complete -F _component_auto_compelete go_update_component

function kill_running_service() {
  [[ "$1" == "" ]] && echo "Missing component name argument" && return 1;
  verify_component $1 || return $?
  local component=$1;
  SERVICE_PID=$(grep_component_pid $component)
  if [[ ! -z ${SERVICE_PID} ]]; then
    kill $SERVICE_PID
  fi
}
# Adding auto tab complete
complete -F _component_auto_compelete kill_running_service

# Helper function to search for the PID of the service
function grep_component_pid {
  [[ "$1" == "" ]] && echo "Missing component name argument" && return 1;
  install_if_missing core/busybox-static pgrep >/dev/null
  pgrep $1
}

document "auto_go_update_component" <<DOC
  Watch for file changes in a component and on change build and update the service.
DOC
function auto_go_update_component() {
  [ "x$1" == "x" ] && echo "Missing component name argument; try 'describe ${FUNCNAME[0]}'" && return 1
  verify_component $1 || return $?
  local component=$1;

  # Need to set the 'pkg_name' back to a2 because when building
  # a component the 'pkg_name' changes to the component name
  pkg_name=a2
  setup_go_workspace

  install_if_missing core/inotify-tools inotifywait
  echo "Starting file watch for $component"
  inotifywait -m -r /src/components/$component -e create -e moved_to -e close_write |
    while read path action file; do
        if [[ "$file" =~ .*go$ ]]; then
          echo "File: $file change in $component"
          go_update_component $component
          echo "Finished update"
        fi
    done
}
# Adding auto tab complete
complete -F _component_auto_compelete auto_go_update_component

document "go_component_static_tests" <<DOC
  Runs the static tests for a component
DOC
function go_component_static_tests() {
  [ "x$1" == "x" ] && echo "Missing component name argument; try 'describe ${FUNCNAME[0]}'" && return 1
  verify_component $1 || return $?
  local component=$1

  echo "Collecting ${component}'s go files"
  local gofiles=$(find components/$component/ -maxdepth 3 -name '*.go');
  [ -z "$gofiles" ] && return 0

  echo "Installing gofmt"
  install_if_missing core/go gofmt

  echo "Testing $component go files"
  unformatted=$(gofmt -l $gofiles)
  if [ -z "$unformatted" ]
  then
    echo "Success!! $component"
    return 0
  fi

  echo >&2 "Failure: Go files must be formatted with gofmt. Please run:"
  for fn in $unformatted; do
    echo >&2 "  gofmt -w $PWD/$fn"
  done

  return 1
}

# Adding auto tab complete
complete -F _component_auto_compelete go_component_static_tests
